# 背包九讲
## 01背包
有N件物品和一个容量为V的背包。第i件物品的费用是`c[i]`,价值是`w[i]`，求哪些物品放入背包可使价值总和最大。
`dp[i][j]:=已经考虑了[0..i-1]`前i个物品，占用了j空间，所能取得的最大价值

将前`i`件物品放入容量为`j`的背包中，若只考虑第`i`件物品的策略：若不放第`i`件物品，转化为前`i-1`件物品放入容量为`j`的背包中，价值为`f[i-1][j]`;若放入第`i`件物品，则问题转化为前`i-1`件物品放入剩下的容量为`j-v[i]`的背包中，此时能获得的最大价值`f[i-1][j-w[i]]+v[i]`
```
dp[i][j]=dp[i-1][j] 当前物品不选
         dp[i-1][j-v[i]]+w[i] 当前物品选，j-v[i]要大于等于0
```
空间优化：
假设状态只有一行，即 `dp[j]:=占用了j空间的情况下可以取到的最大价值`, 在推第`i`行的时候，dp数组中存的是第`i-1`行的信息。看状态的两个转移方向，第一个是`dp[i-1][j]`，这刚好就是当前dp数组在j位置保存的数据，因此不用动，比较麻烦的是另一个，就是`dp[i-1][j-v[i]] + w[i]`。这里要用到第i-1行的 `dp[j-v[i]]`，但是如果按照正常的`j`从 0 到`V`推的话，计算`dp[j]`的时候，`dp[j-v[i]]`保存的已经是第`i`行信息了。因此这里需要转换一下，从大往小推，推到`dp[j]`时，`dp[j+1]`,`dp[j+2]`,...,`dp[V]`都已经是第`i`行的信息了，但是它们对`dp[j]`的计算没有影响，有影响的`dp[j-v[i]]`此时还是第`i - 1`行的信息，可以满足转移方程`dp[i-1][j-v[i]] + w[i]`的需要。因此当空间这一维的状态从大往小推的时候，i这一维状态可以优化到一维。
```
for i=1..N
    for v=V..c[i]
        f[v]=max(f[v],f[v-c[i]]+w[i]])
```
### 初始化
* 恰好装满：除`f[0]`为0，`[1..V]`均为`-inf`。保证最终得到的`f[N]`是恰好装满背包的最优解。
* 不要求装满：将`f[0..V]`设为0
初始化的f数组为没任何物品可放入背包时合法状态，如果要求恰好装满，那么处理容量为0合法，其余均不合法-inf。如果未要求装满，那么都有什么都不装的解0.
## 完全背包
N种物品和容量为V的背包。每种物品无限件可用。求让价值总和最大方案
`dp[i][j]:=已经考虑了[0..i-1]`前`i`个物品，占用了`j`空间，所能取得的最大价值

考虑的状态转移，对于当前物品i，有两种情况：选和不选。
如果选，完全背包中i有无限多个，选了`i`之后前`i`个物品只能占`j-v[i]`空间,`dp[i][j-w[i]]`可能已选入第`i`种物品的子结果。
如果不选，则前`i-1`个物品还是占了`j`空间
```
dp[i][j]=dp[i-1][j] 当前物品不选
         dp[i][j-v[i]]+w[i] 当前物品选，j-v[i]要大于等于0
```
空间优化：
在推导第`i`行`dp[j]`时，用到第`i`行的`dp[j-v[i]]`。故从小往大推`j`即可。